<?php
// @codingStandardsIgnoreFile
/**
 * WordPress media types.
 *
 * @package WordPress
 * @subpackage Media
 * @since xxx
 */

/**
 * Return MIME aliases for a particular file extension.
 *
 * @since xxx
 *
 * @see {https://www.iana.org/assignments/media-types}
 * @see {https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types}
 * @see {http://hg.nginx.org/nginx/raw-file/default/conf/mime.types}
 * @see {https://cgit.freedesktop.org/xdg/shared-mime-info/plain/freedesktop.org.xml.in}
 * @see {https://raw.githubusercontent.com/apache/tika/master/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml}
 * @see {https://github.com/Blobfolio/blob-mimes}
 *
 * @param string $ext File extension.
 * @return array|bool MIME types. False on failure.
 */
function wp_get_mime_aliases( $ext = '' ) {
	$mimes = array(
%MIMES_BY_EXTENSION%
	);

	$ext = trim( strtolower( $ext ) );
	$ext = ltrim( $ext, '.' );
	if ( strlen( $ext ) && isset( $mimes[$ext] ) ) {
		$match = $mimes[$ext];
	}
	else {
		$match = false;
	}

	/**
	 * Filters the MIME alias list.
	 *
	 * @since xxx
	 *
	 * @param array|bool $match The aliases found. False on failure.
	 * @param string $ext The file extension.
	 */
	return apply_filters( 'wp_get_mime_aliases', $match, $ext );
}

/**
 * Check extension and MIME pairing.
 *
 * @since xxx
 *
 * @param string $ext File extension.
 * @param string $mime MIME type.
 * @return bool True/false.
 */
function wp_check_mime_alias( $ext = '', $mime = '' ) {
	// Standardize inputs.
	$mime = strtolower( sanitize_mime_type( $mime ) );
	$ext = trim( strtolower( $ext ) );
	$ext = ltrim( $ext, '.' );

	// Can't continue if the extension is not in the database.
	if ( false === ( $mimes = wp_get_mime_aliases( $ext ) ) ) {
		/**
		 * Filters the extension/MIME check.
		 *
		 * @since xxx
		 *
		 * @param bool $match The result: True or false.
		 * @param string $ext The file extension.
		 * @param string $mime The MIME type.
		 */
		return apply_filters( 'wp_check_mime_alias', false, $ext, $mime );
	}

	// We want to test for both x-subtype and subtype variants.
	$parts = explode( '/', $mime );
	$subtype = count( $parts ) - 1;
	if ( preg_match( '/^x\-/', $parts[$subtype] ) ) {
		$parts[$subtype] = preg_replace( '/^x\-/', '', $parts[$subtype] );
	}
	else {
		$parts[$subtype] = 'x-' . $parts[$subtype];
	}

	// We now have type/x-subtype and type/subtype.
	$test = array(
		$mime,
		implode( '/', $parts )
	);

	// Overlap is success!
	$found = array_intersect( $test, $mimes );
	$match = count( $found ) > 0;

	return apply_filters( 'wp_check_mime_alias', $match, $ext, $mime );
}

/**
 * Retrieve the "real" file type from the file.
 *
 * This extends `wp_check_filetype()` to additionally
 * consider content-based indicators of a file's
 * true type.
 *
 * The content-based type will override the name-based
 * type if available and included in the $mimes list.
 *
 * @since xxx
 *
 * @see wp_check_filetype()
 * @see wp_check_filetype_and_ext()
 *
 * @param string $file Full path to the file.
 * @param string $filename The name of the file (may differ from $file due to $file being in a tmp directory).
 * @param array $mimes Optional. Key is the file extension with value as the mime type.
 * @return array Values with extension first and mime type.
 */
function wp_check_real_filetype( $file, $filename = null, $mimes = null ) {
	// Default filename.
	if ( empty( $filename ) ) {
		$filename = basename( $file );
	}

	// Default MIMEs.
	if ( empty( $mimes ) ) {
		$mimes = get_allowed_mime_types();
	}

	// Run a name-based check first.
	$checked = wp_check_filetype( $filename, $mimes );

	// Only dig deeper if we can.
	if (
		false !== $checked['ext'] &&
		false !== $checked['type'] &&
		file_exists( $file )
	) {
		$real_mime = false;

		try {
			// Try finfo, if available.
			if (
				extension_loaded( 'fileinfo' ) &&
				defined( 'FILEINFO_MIME_TYPE' )
			) {
				$finfo = finfo_open( FILEINFO_MIME_TYPE );
				$real_mime = finfo_file( $finfo, $file );
				finfo_close( $finfo );

				// Account for inconsistent return values.
				if ( ! is_string( $real_mime ) || ! strlen( $real_mime ) ) {
					$real_mime = false;
				}
			}

			// TODO use wp_get_image_mime() as fallback, pending resolution of #40017.
		} catch(Throwable $e) {
			$real_mime = false;
		} catch(Exception $e) {
			$real_mime = false;
		}

		// Evaluate our real MIME.
		if ( false !== $real_mime ) {
			$real_mime = strtolower( sanitize_mime_type( $real_mime ) );
			if ( ! wp_check_mime_alias( $checked['ext'], $real_mime ) ) {
				// If the extension is incorrect but the type is valid,
				// update the extension.
				if ( false !== $extensions = array_search( $real_mime, $mimes, true ) ) {
					$extensions = explode( '|', $extensions );
					$checked['ext'] = $extensions[0];
					$checked['type'] = $real_mime;
				}
				// Otherwise reject the results.
				else {
					$checked['ext'] = false;
					$checked['type'] = false;
				}
			}
		}
	}// End content-based type checking.

	/**
	 * Filters the real check.
	 *
	 * @since xxx
	 *
	 * @param array Found values with extension first and mime type.
	 * @param string $file Full path to the file.
	 * @param string $filename The name of the file (may differ from $file due to $file being in a tmp directory).
	 * @param array $mimes Optional. Key is the file extension with value as the mime type.
	 */
	return apply_filters( 'wp_check_real_filetype', $checked, $file, $filename, $mimes );
}
